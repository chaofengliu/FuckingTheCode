# JVM

## 什么是JVM
JVM（Java Virtual Machine）是java程序运行环境，即二进制字节码的运行环境

### 好处
- 一次编写，到处运行
- 自动内存管理，垃圾回收功能
- 数组下标自动越界检查
- 多态，面向对象的基石

### 比较
JVM
JRE = JVM + 基础类库
JDK = JVM + 基础类库 + 编译工具

## 学习JVM的作用
- 面试
- 理解底层的实现原理
- 中高级程序员的必备技能


## 内存结构
![JVM内存结构图](https://github.com/chaofengliu/LovingTheCode/blob/main/Java/jvm.webp)


1. 程序计数器
2. 虚拟机栈
3. 本地方法栈
4. 堆
5. 方法区

## 程序计数器
程序计数器（Program Counter Register）(寄存器)

- 作用
记住下一条JVM指令的执行地址

- 特点

  - 是线程私有的
  - 不会存在内存溢出

## Java虚拟机栈
虚拟机栈（Java Virtual Machine Stacks）

每个线程运行时需要的内存空间叫做虚拟机栈

每个栈由多个栈帧(Frame)组成，对应着每次方法调用时所占用的内存

栈帧：每个方法内运行需要的内存，包括参数、局部变量、返回地址

每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

### 问题
#### 1、垃圾回收是否涉及栈内存？

不涉及，栈内存里都是栈帧的内存使用，栈帧调用结束后会自动被回收掉，不需要垃圾回收

#### 2、栈内存分配越大越好吗？

我们可以指定栈内存的大小-Xss，默认1024kb，Windows根据实际虚拟内存确定。栈内存越大，最大线程数越少，建议设置过大的栈内存。

#### 3、方法内的局部变量是否线程安全？

如果方法内局部变量没有超出方法的作用范围，线程安全，栈帧是线程私有的，一个线程对应一个栈帧，每个线程的局部变量互不干扰。

### 栈内存溢出

- 栈帧过多导致栈内存溢出
- 栈帧过大导致栈内存溢出

## 本地方法栈
为本地方法接口提供内存空间

## 堆Heap
- 通过new关键字创建对象都会使用对内存

特点

- 它是线程共享的，堆中对象都需要考虑线程安全的问题
- 有垃圾回收机制

### 堆内存溢出

### 堆内存诊断
- jps工具 查看当前系统中有哪些java进程
- jmap工具 查看堆内存占用情况
- jconsole 图形界面，多功能检测佛能根据，可以连续监测

## 方法区
java1.7和1.8对比

![方法区对比](https://github.com/chaofengliu/LovingTheCode/blob/main/Java/area.png)

- Java1.6方法区是PermGen永久代实现，存储类信息、加载器和运行时常量池
- Java1.8方法区存储在Metaspace元空间，运行时常量池放在了堆内存里

### 方法区内存溢出
- 1.8以前会导致永久代内存溢出
java.lang.OutOfMemoryError:PermGen Space
- 1.8之后会导致元空间内存溢出
java.lang.OutOfMemoryError:Metaspace

### 运行时常量池
- 常量池实际上是一张表，虚拟机指令根据这张常量表要执行的类名、方法名、参数类型、字面量等信息
- 运行时常量池，常量池是*.class文件中的，当该类被加载，它的常量池信息就会被放入运行时常量池，把里面的符号地址变为真实地址

### StringTable 常量池
- 常量池中的字符串仅是一个符号，第一次用到时才变成对象
- 利用串池的机制，来避免重复创建字符串对象
- 字符串变量拼接的原理是StringBuilder(1.8）
- 字符串常量拼接的原理是编译期优化
- 可以使用intern方法，主动将串池中还没有的字符串对象放入串池




 