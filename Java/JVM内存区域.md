# JVM

## 什么是JVM
JVM（Java Virtual Machine）是java程序运行环境，即二进制字节码的运行环境

### 好处
- 一次编写，到处运行
- 自动内存管理，垃圾回收功能
- 数组下标自动越界检查
- 多态，面向对象的基石

### 比较
JVM
JRE = JVM + 基础类库
JDK = JVM + 基础类库 + 编译工具

## 学习JVM的作用
- 面试
- 理解底层的实现原理
- 中高级程序员的必备技能


## 内存结构
![JVM内存结构图](https://github.com/chaofengliu/LovingTheCode/blob/main/Java/jvm.webp)

## 运行时数据区域
Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都各有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。Java虚拟机所管理的内存将会包括以下几个运行时数据区域

1. 程序计数器
2. 虚拟机栈
3. 本地方法栈
4. 堆
5. 方法区

## 程序计数器
程序计数器（Program Counter Register）(PC寄存器)

- 程序计数器是一个以线程私有的一块较小的内存空间，用于__记录所属线程所执行的字节码的行号指示器__；字节码解释器工作时，通过改变程序计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳准、异常处理、线程恢复等基础功能都需要依赖程序计数器来完成。

- 在多线程中，就会存在线程上下文切换执行，为了线程切换后能恢复正确的执行位置，所以需要从程序计数器中获取该线程需要执行的字节码的偏移地址。程序计数器是具备线程隔离性，每个线程工作时都有属于自己的独立程序计数器。

- 如果线程执行Java方法，程序计数器记录的是正在执行的虚拟机字节码指令的地址。如果执行Native方法，程序计数器值则为空（Undefined）。因为 Native方法是Java通过JNI直接调用本地C/C++库，可以认为是Native方法相当于C/C++暴露给Java的一个接口，Java通过调用这个接口从而调用到C/C++方法。由于该方法是通过C/C++ 而不是Java进行实现。那么自然无法产生相应的字节码，并且C/C++执行时的内存分配是由自己语言决定的，而不是由JVM决定的。

![Java方法调用图](https://github.com/chaofengliu/LovingTheCode/blob/main/Java/14211474-6b8ee72d2818116c.webp)

- 由于是线程私有的，生命周期随着线程，线程启动而产生，线程结束而消亡。

- Java 虚拟机规范里面，唯一一个没有规定任何OutOfMemoryError情况的区域，由于保存的是线程需要执行的字节码的偏移地址，当执行下一条指令的时候，改变的只是程序计数器中保存的地址，并不需要申请新的内存来保存新的指令地址，因此，不会产生内存溢出。


## Java虚拟机栈
虚拟机栈（Java Virtual Machine Stacks）





每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法


- 每个线程运行时需要的内存空间叫做虚拟机栈，因此虚拟机栈是线程私有的，生命周期随着线程，线程启动而产生，线程结束而消亡。
- 虚拟机栈描述的是Java方法执行的内存模型，用于存储栈帧。所以每个栈由多个栈帧(Frame)组成，对应着每次方法调用时所占用的内存。栈帧是每个方法内运行需要的内存，包括参数、局部变量、返回地址等信息。线程启动时会创建虚拟机栈，每个方法在执行时会在虚拟机栈中创建一个栈帧，用于存储局部变量表、操作数栈、动态连接、方法返回地址、附加信息等信息。每个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中的入栈（压栈）到出栈（弹栈）的过程。
- 虚拟机栈使用的内存不需要保证是连续的。
- 虚拟机规范即允许Java虚拟机栈被实现成固定大小（-Xss），也允许通过计算结果动态来扩容和收缩大小。如果采用固定大小的Java虚拟机栈，那每个线程的Java虚拟机栈容量可以在线程创建的时候就已经确定。


### 问题
#### 1、垃圾回收是否涉及栈内存？

不涉及，栈内存里都是栈帧的内存使用，栈帧调用结束后会自动被回收掉，不需要垃圾回收

#### 2、栈内存分配越大越好吗？

我们可以指定栈内存的大小-Xss，默认1024kb，Windows根据实际虚拟内存确定。栈内存越大，最大线程数越少，建议设置过大的栈内存。

#### 3、方法内的局部变量是否线程安全？

如果方法内局部变量没有超出方法的作用范围，线程安全，栈帧是线程私有的，一个线程对应一个栈帧，每个线程的局部变量互不干扰。

### 栈内存溢出

- 如果线程请求分配的栈容量超过了Java虚拟机栈允许的最大容量，Java虚拟机将会抛出StackOverflowError异常。
- 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将抛出一个OutOfMemoryError异常。

### 栈帧（Stack Frame）

- 栈帧存在于 Java 虚拟机栈中，是 Java 虚拟机栈中的单位元素，每个线程中调用同一个方法或者不同的方法，都会创建不同的栈帧（可以简单理解为，一个线程调用一个方法创建一个栈帧），所以，调用的方法链越多，创建的栈帧越多（代表作：递归）。在 Running 的线程，只有当前栈帧有效（Java 虚拟机栈中栈顶的栈帧），与当前栈帧相关联的方法称为当前方法。每调用一个新的方法，被调用方法对应的栈帧就会被放到栈顶（入栈），也就是成为新的当前栈帧。当一个方法执行完成退出的时候，此方法对应的栈帧也相应销毁（出栈）。

- 栈帧结构图

![结构图](https://github.com/chaofengliu/LovingTheCode/blob/main/Java/14211474-565881c4f597ae76.webp)

### 局部变量表（Local Variable Table）
- 每个栈帧中都包含一组称为局部变量表的变量列表，用于存放方法参数和方法内部定义的局部变量。在 Java 程序编译成 Class 文件时，在 Class 文件格式属性表中 Code 属性的 max_locals（局部变量表所需的存储空间，单位是 Slot） 数据项中确定了需要分配的局部变量表的最大容量。
由于局部变量表建立在线程的堆栈上，是线程的私有数据，无论读写两个连续的 Slot 是否是原子操作，都不会引起数据安全问题。

- 局部变量无初始值（实例变量和类变量都会被赋予初始值），类变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始值；另外一次在初始化阶段，赋予开发者定义的值。因此即使在初始化阶段开发者没有为类变量赋值也没有关系，类变量仍然具有一个确定的默认值。但局部变量就不一样了，如果一个局部变量定义了但没有赋初始值是不能使用的。

### 操作数栈（Operand Stack）
- 操作数栈是一个后入先出（Last In First Out）栈，方法的执行操作在操作数栈中完成，每一个字节码指令往操作数栈进行写入和提取的过程，就是入栈和出栈的过程。
- 同局部变量表一样，操作数栈的最大深度也是Java 程序编译成 Class 文件时被写入到 Class 文件格式属性表的 Code 属性的 max_stacks 数据项中。
- 操作数栈的每一个元素可以是任意的 Java 数据类型，32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2，在方法执行的任何时候，操作数栈的深度都不会超过在 max_stacks 数据项中设定的最大值（指的是进入操作数栈的 “同一批操作” 的数据类型的栈容量的和）。
- 当一个方法刚刚执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，通过一些字节码指令从局部变量表或者对象实例字段中复制常量或者变量值到操作数栈中，也提供一些指令向操作数栈中写入和提取值，及结果入栈，也用于存放调用方法需要的参数及接受方法返回的结果。例如，整数加法的字节码指令 iadd（使用 iadd 指令时，相加的两个元素也必须是 int 型） 在运行的时候将操作数栈中最接近栈顶的两个 int 数值元素出栈相加，然后将相加结果入栈。

### 动态连接（Dynamic Linking）
- 每个栈帧都包含一个指向运行时常量池（JVM 运行时数据区域）中该栈帧所属性方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。
- 在Class文件格式的常量池（存储字面量和符号引用）中存有大量的符号引用（1.类的全限定名，2.字段名和属性，3.方法名和属性），字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载过程的解析阶段的时候转化为直接引用（指向目标的指针、相对偏移量或者是一个能够直接定位到目标的句柄），这种转化称为静态解析。另外一部分将在每一次的运行期期间转化为直接引用，这部分称为动态连接。

### 方法返回地址
- 当一个方法开始执行后，只有两种方式可以退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令（例如：areturn），这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者），是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口（Normal Method Invocation Completion）。
- 另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用 athrow 字节码指令产生的异常，只要在本方法的异常处理器表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口（Abrupt Method Invocation Completion）。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。
- 无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的程序计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。
- 方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整程序计数器的值以指向方法调用指令后面的一条指令等。
- 虚拟机会使用针对每种返回类型的操作来返回，返回值将从操作数栈出栈并且入栈到调用方法的方法栈帧中，当前栈帧出栈，被调用方法的栈帧变成当前栈帧，程序计数器将重置为调用这个方法的指令的下一条指令。

### 附加信息
虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其它附加信息全部归为一类，称为栈帧信息。



## 本地方法栈
本地方法栈（Native Method Stacks）为本地方法接口提供内存空间，为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。

Navtive方法是Java通过JNI直接调用本地C/C++库，可以认为是Native 方法相当于 C/C++ 暴露给 Java 的一个接口，Java 通过调用这个接口从而调用到 C/C++ 方法。当线程调用 Java 方法时，虚拟机会创建一个栈帧并压入 Java 虚拟机栈。然而当它调用的是 native 方法时，虚拟机会保持 Java 虚拟机栈不变，也不会向 Java 虚拟机栈中压入新的栈帧，虚拟机只是简单地动态连接并直接调用指定的 native 方法。

![](https://github.com/chaofengliu/LovingTheCode/blob/main/Java/14211474-fe4b43e1ff9a3386.webp)

- 本地方法栈是一个后入先出（Last In First Out）栈。
- 由于是线程私有的，生命周期随着线程，线程启动而产生，线程结束而消亡。
- 本地方法栈会抛出 StackOverflowError 和 OutOfMemoryError异常。


## 堆Heap
- Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块，也被称为 “GC堆”，是被所有线程共享的一块内存区域，在虚拟机启动时被创建。
- 通过new关键字创建对象都会使用对内存，堆的作用就是储存对象实例和数组（JDK7已把字符串常量池和类静态变量移动到Java堆），几乎所有的对象实例都会存储在堆中分配。
- Java堆是垃圾收集器管理的主要区域。堆内存分为新生代 (Young) 和老年代 (Old) ，新生代 (Young) 又被划分为三个区域：Eden、From Survivor、To Survivor。

![](https://github.com/chaofengliu/LovingTheCode/blob/main/Java/14211474-9c07baf093518ad7.webp)

- 从内存分配的角度看，线程共享的Java 堆中可能划分出多个线程私有的线程本地分配缓存区（Thread Local Allocation Buffer，TLAB）。
- 根据 Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过 -Xmx 和 -Xms 控制）。

![](https://github.com/chaofengliu/LovingTheCode/blob/main/Java/14211474-140412d547164391.webp)


堆的特点

- 它是线程共享的，堆中对象都需要考虑线程安全的问题
- 有垃圾回收机制

### 堆内存溢出
- 如果Java堆可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，那Java虚拟机将抛出一个OutOfMemoryError异常。

### 堆内存诊断
- jps工具 查看当前系统中有哪些java进程
- jmap工具 查看堆内存占用情况
- jconsole 图形界面，多功能检测佛能根据，可以连续监测

## 方法区
java1.7和1.8对比

![方法区对比](https://github.com/chaofengliu/LovingTheCode/blob/main/Java/area.png)

- Java1.6方法区是PermGen永久代实现，存储类信息、加载器和运行时常量池
- Java1.8方法区存储在Metaspace元空间，运行时常量池放在了堆内存里

### 方法区内存溢出
- 1.8以前会导致永久代内存溢出
java.lang.OutOfMemoryError:PermGen Space
- 1.8之后会导致元空间内存溢出
java.lang.OutOfMemoryError:Metaspace

### 运行时常量池
- 常量池实际上是一张表，虚拟机指令根据这张常量表要执行的类名、方法名、参数类型、字面量等信息
- 运行时常量池，常量池是*.class文件中的，当该类被加载，它的常量池信息就会被放入运行时常量池，把里面的符号地址变为真实地址

### StringTable 常量池
- 常量池中的字符串仅是一个符号，第一次用到时才变成对象
- 利用串池的机制，来避免重复创建字符串对象
- 字符串变量拼接的原理是StringBuilder(1.8）
- 字符串常量拼接的原理是编译期优化
- 可以使用intern方法，主动将串池中还没有的字符串对象放入串池




 