# JVM

## 什么是JVM
JVM（Java Virtual Machine）是java程序运行环境，即二进制字节码的运行环境

### 好处
- 一次编写，到处运行
- 自动内存管理，垃圾回收功能
- 数组下标自动越界检查
- 多态，面向对象的基石

### 比较
JVM
JRE = JVM + 基础类库
JDK = JVM + 基础类库 + 编译工具

## 学习JVM的作用
- 面试
- 理解底层的实现原理
- 中高级程序员的必备技能


## 内存结构
![JVM内存结构图](https://github.com/chaofengliu/LovingTheCode/blob/main/Java/jvm.webp)

## 运行时数据区域
Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都各有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。Java虚拟机所管理的内存将会包括以下几个运行时数据区域

1. 程序计数器
2. 虚拟机栈
3. 本地方法栈
4. 堆
5. 方法区

## 程序计数器
程序计数器（Program Counter Register）(PC寄存器)

- 程序计数器是一个以__线程私有__的一块较小的内存空间，用于__记录所属线程所执行的字节码的行号指示器__；字节码解释器工作时，通过改变程序计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳准、异常处理、线程恢复等基础功能都需要依赖程序计数器来完成。

- 在多线程中，就会存在线程上下文切换（CPU时间片[1]）执行，为了线程切换后能恢复正确的执行位置，所以需要从程序计数器中获取该线程需要执行的字节码的偏移地址。程序计数器是具备线程隔离性，每个线程工作时都有属于自己的独立程序计数器。

- 如果线程执行Java方法，程序计数器记录的是正在执行的虚拟机字节码指令的地址。如果执行Native方法，程序计数器值则为空（Undefined）。因为 Native方法是Java通过JNI直接调用本地C/C++库，可以认为是Native方法相当于C/C++暴露给Java的一个接口，Java通过调用这个接口从而调用到C/C++方法。由于该方法是通过C/C++ 而不是Java进行实现。那么自然无法产生相应的字节码，并且C/C++执行时的内存分配是由自己语言决定的，而不是由JVM决定的。

![Java方法调用图](https://github.com/chaofengliu/LovingTheCode/blob/main/Java/14211474-6b8ee72d2818116c.webp)

- 由于是__线程私有的__，生命周期随着线程，线程启动而产生，线程结束而消亡。

- Java 虚拟机规范里面，__唯一一个没有规定任何OutOfMemoryError情况的区域__，由于保存的是线程需要执行的字节码的偏移地址，当执行下一条指令的时候，改变的只是程序计数器中保存的地址，并不需要申请新的内存来保存新的指令地址，因此，不会产生内存溢出。


## Java虚拟机栈
虚拟机栈（Java Virtual Machine Stacks）

每个线程运行时需要的内存空间叫做虚拟机栈

每个栈由多个栈帧(Frame)组成，对应着每次方法调用时所占用的内存

栈帧：每个方法内运行需要的内存，包括参数、局部变量、返回地址

每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

### 问题
#### 1、垃圾回收是否涉及栈内存？

不涉及，栈内存里都是栈帧的内存使用，栈帧调用结束后会自动被回收掉，不需要垃圾回收

#### 2、栈内存分配越大越好吗？

我们可以指定栈内存的大小-Xss，默认1024kb，Windows根据实际虚拟内存确定。栈内存越大，最大线程数越少，建议设置过大的栈内存。

#### 3、方法内的局部变量是否线程安全？

如果方法内局部变量没有超出方法的作用范围，线程安全，栈帧是线程私有的，一个线程对应一个栈帧，每个线程的局部变量互不干扰。

### 栈内存溢出

- 栈帧过多导致栈内存溢出
- 栈帧过大导致栈内存溢出

## 本地方法栈
为本地方法接口提供内存空间

## 堆Heap
- 通过new关键字创建对象都会使用对内存

特点

- 它是线程共享的，堆中对象都需要考虑线程安全的问题
- 有垃圾回收机制

### 堆内存溢出

### 堆内存诊断
- jps工具 查看当前系统中有哪些java进程
- jmap工具 查看堆内存占用情况
- jconsole 图形界面，多功能检测佛能根据，可以连续监测

## 方法区
java1.7和1.8对比

![方法区对比](https://github.com/chaofengliu/LovingTheCode/blob/main/Java/area.png)

- Java1.6方法区是PermGen永久代实现，存储类信息、加载器和运行时常量池
- Java1.8方法区存储在Metaspace元空间，运行时常量池放在了堆内存里

### 方法区内存溢出
- 1.8以前会导致永久代内存溢出
java.lang.OutOfMemoryError:PermGen Space
- 1.8之后会导致元空间内存溢出
java.lang.OutOfMemoryError:Metaspace

### 运行时常量池
- 常量池实际上是一张表，虚拟机指令根据这张常量表要执行的类名、方法名、参数类型、字面量等信息
- 运行时常量池，常量池是*.class文件中的，当该类被加载，它的常量池信息就会被放入运行时常量池，把里面的符号地址变为真实地址

### StringTable 常量池
- 常量池中的字符串仅是一个符号，第一次用到时才变成对象
- 利用串池的机制，来避免重复创建字符串对象
- 字符串变量拼接的原理是StringBuilder(1.8）
- 字符串常量拼接的原理是编译期优化
- 可以使用intern方法，主动将串池中还没有的字符串对象放入串池




 